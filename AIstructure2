package rpgGridBrawl;
/**
 * This object coordinates the activity of AIsensors, AIhands, and AInode to produce an AIresult object that details what the AI's
 * decision should be.  It's called "structure2" because it is an improved version.  The first AIstructure could only play the
 * Square-Off--this one can do the Brawl also.  It only looks at the current turn and determines what action would lead to the best
 * "Advantage" (the difference between the two player scores) and so it could be called a "greedy algorithm".
 * There will be an AIstructure3, which will look ahead a couple of turns.
 * 
 *
 */

public class AIstructure2 {
	private AInode node;
	private AIsensors sensor;
	private boolean[] onSwitches;
	private int idealSpots, mostIdealspot, brawlerToPlace;
	private double bestAdvantages, veryBestAdvantage;
	
	public AIstructure2(String nodeString) {
		node = new AInode(nodeString);
		node = setNodeArtifacts(node);
		sensor = new AIsensors(nodeString);
		idealSpots = 0;
		mostIdealspot = 0;
		brawlerToPlace = -1;
		bestAdvantages = 0.0;
		veryBestAdvantage = 0.0;		
	}
	
	public AIsensors getSensor() 				{ return this.sensor; }
	public boolean getOnSwitch(int x) 			{ return this.onSwitches[x]; }
	public int getIdealSpots() 					{ return this.idealSpots; }
	public int getMostIdealSpot() 				{ return this.mostIdealspot; }
	public int getBrawlerToPlace() 				{ return this.brawlerToPlace; }
	public double getBestAdvantages() 			{ return this.bestAdvantages; }
	public double getVeryBestAdvantage() 		{ return this.veryBestAdvantage; }
	public void setOnSwitches(boolean[] x) 		{ this.onSwitches = x; }
	public void setIdealSpots(int x) 			{ this.idealSpots = x; }
	public void setMostIdealSpot(int x) 		{ this.mostIdealspot = x; }
	public void setBrawlerToPlace(int x) 		{ this.brawlerToPlace = x; }
	public void setBestAdvantages(double x) 	{ this.bestAdvantages = x; }
	public void setVeryBestAdvantage(double x) 	{ this.veryBestAdvantage = x; }
	
	public AIresult bestSquareOffAction(boolean redsTurn) {
		AIresult tester;
		this.setOnSwitches(setSQOSwitches(this.getNode()));
		for (int m = 0; m < 24; m++) {
			if (this.getOnSwitch(m)) {
				tester = this.getSensor().bestActionByBrawler(m, redsTurn);
				this.setIdealSpots(tester.getIdealPlace());
				this.setBestAdvantages(tester.getBestAdv());
				boolean bestRedPlace = ((this.getBestAdvantages() > this.getVeryBestAdvantage()) && redsTurn);
				boolean bestBluePlace = ((this.getBestAdvantages() < this.getVeryBestAdvantage()) && !redsTurn);
				if (bestRedPlace || bestBluePlace || this.getBrawlerToPlace() == -1) {
					this.setVeryBestAdvantage(this.getBestAdvantages());
					this.setMostIdealSpot(tester.getIdealPlace());
					this.setBrawlerToPlace(m);
				}
			}
		}
		return new AIresult(this.getBrawlerToPlace(), 1, this.getMostIdealSpot(), -1, this.getVeryBestAdvantage(), redsTurn);
	}
	
	public AIresult bestBrawlAction(boolean redsTurn) {
		AIresult tester;
		this.setOnSwitches(this.setBrawlSwitches(this.getNode()));
		AIresult bestResult = new AIresult(this.getNode().getAdvantage(), redsTurn);
		boolean gotInitial = false, bestRedAction = false, bestBlueAction = false;
		double rando = 0.25;
		boolean goodResult = false;
		do {
			for (int n = 0; n < 24; n++) {
				if (this.getOnSwitch(n)) {
					tester = this.getSensor().bestActionByBrawler(n, redsTurn);
					boolean goForIt = (Math.random() < rando);
					double tst = tester.getBestAdv(), bst = bestResult.getBestAdv();
					bestRedAction = (redsTurn && ((tst > bst) || (tst == bst && goForIt)));
					bestBlueAction = (!redsTurn && ((tst < bst) || (tst == bst && goForIt)));
					if ((bestRedAction || bestBlueAction || !gotInitial) && tester.getAction() != 0) {
						gotInitial = true;
						bestResult = tester;
					}
				}
			}
			if (bestResult.getAction() != 0) goodResult = true;
			rando += 0.05;
		} while(!goodResult);
		return bestResult;
	}
	
	private String showPG(AInode node, int id) {
		int[] pg = node.buildPlayground(id);
		String report = "(";
		for (int i = 0; i < pg.length; i++) report += (pg[i] + ", ");
		report += ")";
		return report;
	}
	
	
	
	// this works for the SquareOff only
	public boolean[] setSQOSwitches(AInode seed) { 
		boolean[] swtchs = new boolean[24];
		
		for (int k = 0; k < 24; k++) {
			Brawler bb = seed.getBrawler(k);
			swtchs[k] = true;
			if (bb.isOnBoard() || bb instanceof Nemesis) swtchs[k] = false;
			else if ((seed.isRedsTurn() && bb.isBlue()) || (!seed.isRedsTurn() && bb.isRed())) swtchs[k] = false;
		}
		int chOnBrd = 0;
		if (seed.isRedsTurn()) {
			for (int r = 0; r <= 3; r++) if (seed.getBrawler(r).isOnBoard()) chOnBrd++;
		}
		else {
			for (int b = 4; b <= 7; b++) if (seed.getBrawler(b).isOnBoard()) chOnBrd++;
		}
		if ((seed.getRound() + (4 - chOnBrd)) > 10) {
			for (int x = 8; x <= 23; x++) swtchs[x] = false; // keeps the AI from procrastinating.
		}
		
		return swtchs;
	}	
	
	public AInode getNode() { return this.node; }
	
	public boolean[] setBrawlSwitches(AInode seed) {
		boolean[] switches = new boolean[24];
		for (int m = 0; m < 24; m++) {
			Brawler dd = seed.getBrawler(m);
			if (seed.getRedLU() == m) switches[m] = false;
			else if (seed.getBlueLU() == m) switches[m] = false;
			else if ((seed.isRedsTurn() && dd.isBlue()) || (!seed.isRedsTurn() && dd.isRed())) switches[m] = false;
			else if (!seed.canRedPlace() && !dd.isOnBoard() && seed.isRedsTurn()) switches[m] = false;
			else if (!seed.canBluePlace() && !dd.isOnBoard() && !seed.isRedsTurn()) switches[m] = false;
			else if (dd.isOnBoard() && seed.getLocation(dd.getLoc()).isGhostEffect()) switches[m] = false;
			else if (dd instanceof Rogue && (seed.getBrawler("Sentinel").getFloor() == dd.getFloor())) switches[m] = false;
			else switches[m] = true;
		}
		return switches;
	}
	
	private static AInode setNodeArtifacts(AInode fixNode) {
		Brawler ghost = fixNode.getBrawler("Ghost");
		if (!ghost.isOnBoard()) fixNode.removeEffects(ghost.getPieceID());
		else fixNode.addGhostEffect(ghost.getFloor(), ghost.getColumn(), ghost.getRow());
		Brawler leper = fixNode.getBrawler("Leper");
		if (!leper.isOnBoard()) fixNode.removeEffects(leper.getPieceID());
		else fixNode.addLeperOrSentinelEffect(leper.getFloor(), 'L');
		Brawler sentinel = fixNode.getBrawler("Sentinel");
		if (!sentinel.isOnBoard()) fixNode.removeEffects(sentinel.getPieceID());
		else fixNode.addLeperOrSentinelEffect(sentinel.getFloor(), 'S');
		return fixNode;
	}
	
	public void resetNode(String node) {
		this.node.setToString(node);
	}
	
	

} // end of AIstructure2 class
